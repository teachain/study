# 树

1. 结点拥有的子树数称为结点的度(Degree)。
2. 度为0的结点称为叶结点(Leaf)或终端结点;
3. 度不为0的结点称为非终端结点或分支结点。
4. 除根结点之外，分支结点也称为内部结点。
5. 树的度是树内各结点的度的最大值
6. 结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层
7. 树中结点的最大层次称为树的深度(Depth)或高度

树的结点包含一个数据元素及若干指向其子树的分支。

利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。

- 双亲表示法

  | 节点的数据 | 双亲的指针（或是下标） |
  | ---------- | ---------------------- |
  | data       | parent                 |

  由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。

  存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。

  也就是说节点的结构应该设计成什么样子的，完全取决于你要实现怎样的一个功能。比如说：

  ```
  type Node struct{
      data []byte
      parent * Node
  }
  //当我需要快速知道孩子的节点的时候，我可以定义为
  type Node struct{
      data []byte
      parent * Node
      child * Node
  }
  ```

- 孩子表示法

  由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。

  1. 方案一

     一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。

  2. 方案二

     第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数

  我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系 。
  这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中，

- 孩子兄弟表示法

  刚才我们分别从双亲的角度和从孩子的角度研究树的存储结构，如果我们从树结点的兄弟的角度又会如何呢? 当然，对于树这样的层级结构来说，只研究结点的兄弟是不行的，我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。 因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。





**Trie**，又称为字典树或者前缀树 (prefix tree)，属于查找树的一种。它与平衡二叉树的主要不同点包括：

- 每个节点数据所携带的 key 不会存储在 Trie 的节点中，而是通过该节点在整个树形结构里位置来体现

  这个应该怎么理解呢，举个例子吧，比如key为"a78ds",value为89的这个节点，A为root node,B为A的子节点

  它的key为a7，c是B的子节点，它的key为8ds,value为89，也就是说key(a78ds)并不在Trie的节点中，而是通

  过这样子的父子关系将key从父到子连接起来形成一个key作为数据的key,然后它的value为数据的value。

- 同一个父节点的子节点，共享该父节点的 key 作为它们各自 key 的前缀，因此根节点 key 为空；

   搜索路径从根节点开始，所以跟节点的key为空（要是它不为空，怎么兼容所有的字符串？）

- 待存储的数据只存于叶子节点和部分内部节点中，非叶子节点帮助形成叶子节点 key 的前缀。

  因为要共享前缀，所以会有非叶子节点的存在



**PatriciaTrie**，又被称为 RadixTree 或紧凑前缀树 (compact prefix tree)，是一种空间使用率经过优化的 Trie。与 Trie 不同的是，PatriciaTrie 里如果存在一个父节点只有一个子节点，那么这个父节点将与其子节点合并。这样可以缩短 Trie 中不必要的深度，大大加快搜索节点速度。



**MerkleTree**

在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个” 子哈希 “。于是往上推，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root。

   这个怎么来理解呢，你可以这样子想象，一棵树（现实生活中的树），从叶子开始，叶子的哈希并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，从上往下看，它属于两个叶子的孩子（类比），但如果从计算机的树来看就是生成父节点（孩子生老子的，逆天呀）



## Merkle-Patricia Trie(MPT) 的实现

MPT 是 Ethereum 自定义的 Trie 型数据结构。在代码中，trie.Trie 结构体用来管理一个 MPT 结构，其中每个节点都是行为接口 Node 的实现类

### 一定要记得底层数据存储是【k,v】结构

任何一个[k,v]类型数据被插入一个MPT时，会以k字符串为路径沿着root向下延伸，在此次插入结束时首先成为一个shortNode，k会以自顶点root起到到该节点止的key path形式存在。但之后随着其他节点的不断插入和删除，根据MPT结构的要求，原有节点可能会变化成其他node实现类型，同时MPT中也会不断裂变或者合并出新的节点。比如：

- 假设一个shortNode S已经有一个子节点A，现在要新插入一个子节点B，那么会有两种可能，如果节点A为fullNode,那么新节点B沿着A的路径继续向下，这样S的子节点会被更新；如果节点A为valueNode,那么S的Key分裂成两段，前一段的公共部分分配给S作为新的Key，同时裂变出一个新的fullNode作为S的子节点，以同时容纳B，以及需要更新的A。
- 如果一个fullNode原本只有两个子节点，现在要删除其中一个子节点，那么这个fullNode就会退化为shortNode，同时保留的子节点如果是shortNode，还可以跟它再合并。
- 如果一个shortNode的子节点是valueNode同时又被删除了，那么这个shortNode就会退化成一个valueNode

```
注意：黄皮书中把节点类型概括为了分支节点、扩展节点和叶子节点。fullNode对应了黄皮书里面的分支节点，shortNode对应了黄皮书里面的扩展节点和叶子节点(通过shortNode.Val的类型来对应到底是叶子节点还是分支节点，如果是valueNode，就是叶子节点，否则是分支节点)

```



### 特殊的那个 - hashNode

hashNode 跟 valueNode 一样，也是字符数组 []byte 的一个别名，同样存放 32byte 的哈希值，也没有子节点。不同的是，**hashNode 是 fullNode 或者 shortNode 对象的 RLP 哈希值**，所以它跟 valueNode 在使用上有着莫大的不同。

在 MPT 中，hashNode 几乎不会单独存在 (有时遍历遇到一个 hashNode 往往因为原本的 node 被折叠了)，而是以 nodeFlag 结构体的成员(nodeFlag.hash) 的形式，被 fullNode 和 shortNode 间接持有。一旦 fullNode 或 shortNode 的成员变量 (包括子结构) 发生任何变化，它们的 hashNode 就一定需要更新。所以在 trie.Trie 结构体的 insert()，delete()等函数实现中，可以看到除了新创建的 fullNode、shortNode，那些子结构有所改变的 fullNode、shortNode 的 nodeFlag 成员也会被重设，hashNode 会被清空。在下次 trie.Hash()调用时，整个 MPT 自底向上的遍历过程中，所有清空的 hashNode 会被重新赋值。这样 trie.Hash()结束后，我们可以得到一个根节点 root 的 hashNode，它就是**此时此刻这个 MPT 结构的哈希值**。

明显的，hashNode 体现了 **MerkleTree** 的特点：每个父节点的哈希值来源于所有子节点哈希值的组合，一个顶点的哈希值能够代表一整个树形结构。hashNode 加上之前的 fullNode，shortNode，valueNode，构成了一个完整的 Merkle-PatriciaTrie 结构



## MPT 中对 key 的编码

MPT中涉及到了三种编码，分别为keybytes编码、Hex编码和Compact编码

**keybytes 编码**这种编码格式就是原生的key字节数组，大部分的Trie的API都是使用这边编码格式（就是[]byte）

**Hex  编码**: 当 [k,v] 数据插入 MPT 时，它们的 k(key)都必须经过编码。这时对 key 的编码，要保证原本是 []byte 类型的 key 能够以 16 进制形式按位进入 fullNode.Children[]，因为 Children[] 数组最多只能容纳 16 个子节点。相应的，Ethereum 代码中在这里定义了一种编码方式叫 Hex，将 1byte 的字符大小限制在 4bit(16 进制)以内。

先来看 **Hex 编码**的实现

很简单，就是将 keybytes 中的 1byte 信息，将高 4bit 和低 4bit 分别放到两个 byte 里，最后在尾部加 1byte 标记当前属于 Hex 格式。这样新产生的 key 虽然形式还是 []byte，但是每个 byte 大小已经被限制在 4bit 以内，代码中把这种新数据的每一位称为 nibble。这样经过编码之后，带有[]nibble 格式的 key 的数据就可以顺利的进入 fullNode.Children[] 数组了。举个例子就是   [10]byte

假设byte[i]的数据是（一个字节）

11010110

进行Hex编码就是分成

nibble[2*i]为

00001101

nibble[2* i+1]为

00000110   

最后在编完这个字节数组 ([10]byte)之后，多加一个字节用来标记它是Hex编码的

00010000

Hex 编码虽然解决了 key 是 keybytes 形式的数据插入 MPT 的问题，但代价也很大，就是数据冗余。典型的如 shortNode，目前 Hex 格式下的 Key，长度会变成是原来 keybytes 格式下的两倍。这一点对于节点的哈希计算，比如计算 hashNode，影响很大。所以 Ethereum 又定义了另一种编码格式叫 Compact，用来对 Hex 格式进行优化。

```
节点被加载到内存里面的时候key使用的是这种编码，因为它的方便访问。
```



**Compact 编码**:又叫 hex prefix 编码，它的主要意图是将 Hex 格式的字符串恢复到 keybytes 的格式，同时要加入

当前 Compact 格式的标记位，还要考虑在奇偶不同长度 Hex 格式字符串下，避免引入多余的 byte。

- Compact 编码首先将 Hex 尾部标记 byte 去掉，然后将原本每 2 nibble 的数据合并到 1byte；
- 增添 1byte 在输出数据头部以放置 Compact 格式标记位00100000；
- 如果输入 Hex 格式字符串有效长度为奇数，还可以将 Hex 字符串的第一个 nibble 放置在标记位 byte 里的低 4bit,并增加奇数位标志 0011xxxx。





