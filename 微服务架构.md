# 微服务

```
服务之间用同步协议比如HTTP/REST或者异步协议比如AMQP（实现如RabbitMQ等）来进行通信。 服务可以被独立的开发和部署。每个服务有自己独立的数据库，从而与别的服务解耦。服务之间的数据一致性通过使用事件驱动架构来维护。
```

```
一个应用必须使用事件驱动架构。一个服务在它的数据变化时，会发布一个事件。别的服务消费这个事件，然后更新自己的数据。有很多种可靠的数据更新和事件发布的方法，包括事件源和事务日志跟踪。
```

优点：

- 每个微服务相对都比较小。
- 每个服务可以独立于其他服务单独部署，利于频繁部署新版本。
- 更容易伸缩开发资源。使你可以把开发资源分成多个团队。每个团队负责一个或多个服务。
- 提高了错误的隔离。比如说，在一个服务中产生了内容泄露，只有那一个服务会受影响。
- 不会对一个技术栈产生长期的依赖。在开发一个新服务或者重写服务时，可以选择新的技术栈。

缺点：

- 开发者需要处理创建一个分布式系统时的额外的复杂度

  -  测试更复杂
  - 开发者必须实现服务间的通信机制
  - 如果不使用分布式事务，会很难实现跨多个服务的用例
  - 实现跨多个服务的用例需要团队间的更认真的合作

- 部署复杂性。在生产环境下，部署或者管理一个微服务系统有运维方面的复杂性。

- 更高的内存消耗。微服务架构需要N*M个实例，而单一架构只需要N个实例。如果每个服务在它自己的JVM上运行， 就需要M倍的JVM运行时。

  ​

  # 分布式追踪

  我们可以在service中加入这样的代码：

  - 给每个单个的请求一个唯一的request id
  - 把这个request id传递给别的与处理这个请求相关的service
  - 把这个request id加入到所有的log信息中
  - 把请求的信息（比如开始时间，结束时间）和在处理这个请求时的行为记录

  ## 微服务划分

  在微服务体系中，如何切分微服务也是一个重要的话题，在我们的实践中，我们遵循了如下一些原则：

  1. 逻辑独立、边界清晰的模块作为一个独立的微服务
  2. 每个table只由一个微服务操作（包括插入、读取、更改、删除等）
  3. table之间不引入外键约束，id字段全部采用uuid
  4. 将需要保持数据一致性的操作放在一个微服务中，避免跨服务带来的数据一致性难题
  5. 微服务之间的通信，尽可能采用消息队列实现松耦合，当需要同步调用时再借助于rpc
  6. 微服务独立部署，通过etcd实现服务的注册与发现


### Gateway

Gateway是微服务对外提供服务的一个屏障，它的核心点在于：

1. 屏蔽微服务之间通过消息队列、rpc等通信方式，为Web页面和移动APP提供基于HTTP协议的RESTful API接口
2. 对每一个http业务请求进行必要的鉴权和数据完整性、合法性检查，以减少微服务的负担，让微服务的代码更纯粹
3. 微服务部署体系中，每个微服务可能会部署多个实例，Gateway还承担着在这些实例中进行负载均衡的功能
4. 进行必要的日志输出、监控打点等功能，对每一个来自于APP和页面的http请求，生成一个唯一的trace id，并将trace id传导到每一个后续的微服务中，以便后续的查错和性能调优
5. Gateway的每一个http请求都是无状态的，采用JWT（Json Web Token）机制实现一个客户端的请求状态信息的传递

微服务体系中，服务的注册和发现对整体架构非常重要，尤其对于同步的rpc调用，每个服务有多少实例，每个实例的地址等，都需要有一个统一的管理。我们采用etcd保存服务信息，同时封装了wonaming作为微服务注册和发现的中间件，它的主要功能包括：

1. 服务在启动时，调用wonaming向etcd注册包含TTL的服务“索引”、
2. 注册后，服务与etcd保持定时心跳，当微服务主动退出或超时，服务解注册并“下线”
3. 在Gateway中，通过resolver进行服务发现，配合grpc提供的balancer实现负载均衡，resolver启动后会对etcd中的 /wonaming 目录进行监控，当有服务注册或者解注册时，动态维护可用服务清单。