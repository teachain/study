在go语言中，一般建议package的名称和目录名保持一致

##如何进行编译安装##

有两种方式可以进行安装

1、只要进入对应的应用包目录，然后执行go install，就可以安装了

2、在任意的目录执行如下代码go install mymath

也就是说应用包肯定是在GOPATH/src下的，这个要切记，这样，当你执行go的一些命令时，都会从GOPATH/src下开始。
如果一个应用包是多级目录的，就在import里面引入多级目录，如果你有多个GOPATH，也是一样，Go会自动在多个$GOPATH/src中寻找。
import的时候，记得从src下的第一级目录开始，比如有一个包的路径是
$GOPATH/src/github.com/dm/mathapp,那么我们进行import的时候
坚持这样写

```
   import("github.com/dm/mathapp")
```

就不很容易管理应用包了。

##如何编译成二进制的可执行文件##
进入包含package main的源码文件的应用目录，注意，这个目录下必须有一个go文件里有一个func main函数,也就是必须是

```
package main

func main(){

}
```

这是编译成可执行文件的基础。进入应用目录以后

* 执行go build 命令，在应用目录下生成可执行文件。

* 执行go install 命令，在$GOPATH/bin目录下生成可执行文件。


##获取远程包##
go语言有一个获取远程包的工具就是go get
go get -u 参数可以自动更新包，而且当go get的时候会自动获取该包依赖

的其他第三方包

通过这个命令可以获取相应的源码，对应的开源平台采用不同的源码控制工具，例如github采用
git、googlecode采用hg，所以要想获取这些源码，必须先安装相应的源码控制工具
也就是如果你要进行go get的源代码在github上，那么你要执行go get的话，就必须事先安装
好git,如果源码在googlecode上的话，就必须事先安装hg,其他同理。

<font color="red">go get本质上可以理解为首先第一步是通过源码工具clone代码到src下面，然后执行go install

在代码中如何使用远程包，很简单的就是和使用本地包一样，只要在开头import相应的路径就可以</font>

如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件

go build的时候会选择性地编译以系统名结尾的文件

其它系统命名后缀文件全部忽略。


每一个可独立运行的Go程序，必定包含一个package main，在这个main包中必定包含一个入口函数main，而这个函数既没有参数，也没有返回值。


<font color="red">make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。</font>

##传值和传指针##
当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。
当我们传入一个指针变量的时候，此时参数仍然是按copy传递的，只是copy的是一个指针。也就是你仍然得到了一个变量的地址（我们知道得到了地址，那么我们想干啥就干啥，权力好大），也就是这个地址的拷贝。

传指针的好处

* 传指针使得多个函数能操作同一个对象。
* 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。
* Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）

在Go中函数也是一种变量，我们可以通过type来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型
























