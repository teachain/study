

用户只要有证明其控制权的密钥，用密钥解锁，就可以发送比特币。这些密钥通常存储在计算机的数字钱包里。拥有密钥是使用比特币的唯一条件，这让控制权完全掌握在每个人手中。

比特币是一个分布式的点对点网络系统

> 比特币由这些构成：

- 一个去中心化的点对点网络（比特币协议）
- 一个公共的交易账簿（区块链）
- 一个去中心化的数学的和确定性的货币发行（分布式挖矿）
- 一个去中心化的交易验证系统（交易脚本）

#### 完整客户端（bitcoind）

一个完整客户端，或称“全节点”，是存储所有比特币交易的整个交易历史（由每一个用户完成的每一笔交易，曾经所有的每一笔）的客户端，管理用户的钱包，并可以在比特币网络上直接开始交易。

[https://bitcoin.org](https://bitcoin.org/)



交易就像复式记账法账簿中的行



###  常见的交易形式

* 一般交易有一个输入和两个输出
* 集合多个输入到一个输出，这相当于现实生活中将很多硬币和纸币零钱兑换为一个大额面钞。像这样的交易有时由钱包应用产生来清理许多在支付过程收到的小数额的找零。
* 将一个输入分配给多个输出，即多个接收者的交易。这类交易有时被商业实体用作分配资金，例如给多个雇员发工资的情形。



A给B转账：

交易的输出会被创建成为一个包含这笔数额的脚本的形式，只能被引入这个脚本的一个解答后才能兑换。简单点说就是，A的交易输出会包含一个脚本，这个脚本说 “这个输出谁能拿出一个签名和B的公开地址匹配上，就支付给谁”。因为只有B的钱包的私钥可以匹配这个地址，所以只有B的钱包可以提供这个签名以兑换这笔输出。



比特币网络的目的是将交易和区块传播给所有参与者。



比特币系统的信任是建立在计算的基础上的。交易被包在一起放进区块中时需要极大的计算量来证明，但只需少量计算就能验证它们已被证明。挖矿在比特币系统中起着两个作用：

▷ 挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。每个区块创造的比特币数量是固定的，随时间会渐渐减少。

▷ 挖矿创建信任。挖矿确保只有在包含交易的区块上贡献了足够的计算量后，这些交易才被确认。区块越多，花费的计算量越大，意味着更多的信任。

基于哈希加密算法的，其展现了相似的特性：非对称地，它解起来困难而验证很容易，并且它的困难度可以调整。

新交易不断地从用户钱包和应用流入比特币网络。当比特币网络上的节点看到这些交易时，会先将它们放到各自节点维护的一个临时的未经验证的交易池中。当矿工构建一个新区块时，会将这些交易从这个交易池中拿出来放到这个新区块中，然后通过尝试解决一个非常困难的问题（也叫工作量证明）以证明这个新区块的合法性。

矿工一旦从网络上收到一个新区块时，会意识到在这个区块上的解题竞赛已经输掉了，会马上开始下一个新区块的挖掘工作。它会立刻将一些交易和这个新区块的数字指纹放在一起开始构建下一个新区块，并开始给它计算工作量证明。每个矿工会在他的区块中包含一个特殊的交易，将新生成的比特币（当前每区块为25比特币）作为报酬支付到他自己的比特币地址。如果他找到了使得新区块有效的解法，他就会得到这笔报酬，因为这个新区块被加入到了总区块链中，他添加的这笔报酬交易也会变成可消费的。参与矿池的Jing设置了他的软件，使得构建新区块时会将报酬地址设为矿池的地址。



```
#加密钱包，foo为密码
bitcoin-cli encryptwallet foo 

#解锁钱包，foo为密码，360表示360秒后会再次锁上
bitcoin-cli walletpassphrase foo 360 

#备份钱包，wallet.backup为备份的文件名
bitcoin-cli backupwallet wallet.backup 

#为了重新加载备份文件，我们使用importwallet命令。如果你的钱包处于锁定状态，你将需要先将钱包解锁
bitcoin-cli importwallet wallet.backup 

#dumpwallet 命令用来将钱包转储为人类可读的文本文件
bitcoin-cli dumpwallet wallet.txt

#获取一个新的地址
bitcoin-cli getnewaddress

#获取接收的交易，1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL为地址，0为确认数
bitcoin-cli getreceivedbyaddress 1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL 0

#整个钱包接收到的交易
bitcoin-cli listtransactions

#列出整个钱包的所有地址
bitcoin-cli getaddressesbyaccount ""

#如果交易还未被确认，getbalance返回的余额将为0。配置项“minconf”决定了交易在余额中体现的最少确认数。
#getbalance命令将显示所有经过至少minconf个确认的交易加和后的余额
bitcoin-cli getbalance

#通过交易哈希值获取一笔交易
bitcoin-cli gettransaction 交易哈希值

#整个交易以一个“原始”的十六进制字符串的形式返回
bitcoin-cli getrawtransaction 交易哈希值

#解码上一条命令得到的十六进制字符串成一个完整的交易
bitcoin-cli decoderawtransaction 十六进制字符串

#使用getblock命令，并把区块哈希值作为参数来查询对应的区块
bitcoin-cli getblock  区块哈希

#getblockhash命令通过区块高度来检索一个区块，这样需要将区块高度作为参数，并返回那个区块的区块哈希值。
bitcoin-cli getblockhash 0

#使用listunspent命令去查看我们钱包中所有剩余的从之前交易中已确认的支出
bitcoin-cli listunspent

#gettxout命令来得到未花费的输出的详细细节。txid为交易哈希，vout为索引
bitcoin-cli gettxout txid vout

#用createrawtransaction命令去建立一笔交易，命令产生了一个原始十六进制字符串返回
#用decoderawtransaction可解码
#输入和输出之间的差额就作为手续费
 bitcoin-cli createrawtransaction '[{"txid" : "9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3", "vout" : 0}]' '{"1LnfTndy3qzXGN19Jwscj1T8LR3MVe3JDb": 0.025, "1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL": 0.0245}'


#signrawtransaction 命令去签名交易。它需要原始十六进制的字符串作为参数
#参数就是createrawtransaction命令返回的结果
#如果钱包加锁了，先解锁
#一个加密的钱包在签名之前必须解密，因为签名需要利用钱包中的秘钥。
#结果得到另一串十六进制的原始加密交易（注意是json格式，要取hex字段，可以用decoderawtransaction查看）
bitcoin-cli signrawtransaction 原始十六进制字符串

#提交新交易到比特币网络，返回交易的哈希值
bitcoin-cli sendrawtransaction 一串十六进制的加密交易
```



一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）

比特币私钥只是一个数字。你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。该私钥可进一步生成公钥。

Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例如“+”和“/”），用于在电子邮件这样的基于文本的媒介中传输二进制数据。



Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。这种编码格式不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。

***简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。***



公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。一共就是520bit,04占8个bit

**前缀04是用来区分非压缩格式公钥**

**压缩格式公钥是以02或者03开头。**

引入压缩格式公钥是为了减少比特币交易的字节数，从而可以节省那些运行区块链数据库的节点磁盘空间。

一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解。因此，如果我们知道了公钥的x坐标，就可以通过解方程y2 mod p = (x3 + 7) mod p得到y坐标。这种方案可以让我们只存储公钥的x坐标，略去y坐标，从而将公钥的大小和存储空间减少了256比特。每个交易所需要的字节数减少了近一半，随着时间推移，就大大节省了很多数据传输和存储。

未压缩格式公钥使用04作为前缀，而压缩格式公钥是以02或03作为前缀。需要这两种不同前缀的原因是：因为椭圆曲线加密的公式的左边是y2 ，也就是说y的解是来自于一个平方根，可能是正值也可能是负值。更形象地说，y坐标可能在x坐标轴的上面或者下面。从图4-2的椭圆曲线图中可以看出，曲线是对称的，从x轴看就像对称的镜子两面。因此，如果我们略去y坐标，就必须储存y的符号（正值或者负值）。换句话说，对于给定的x值，我们需要知道y值在x轴的上面还是下面，因为它们代表椭圆曲线上不同的点，即不同的公钥。当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。因此，为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。这样就可以根据公钥中给定的x值，正确推导出对应的y坐标，从而将公钥解压缩为在椭圆曲线上的完整的点坐标。

### 比特币交易在比特币网络中的传播

一旦一笔比特币交易被发送到任意一个连接至比特币网络的节点，这笔交易将会被该节点验证。如果交易被验证有效，该节点将会将这笔交易传播到这个节点所连接的其他节点；同时，交易发起者会收到一条表示交易有效并被接受的返回信息。如果这笔交易被验证为无效，这个节点会拒绝接受这笔交易且同时返回给交易发起者一条表示交易被拒绝的信息。



比特币交易的基本单位是未经使用的一个交易输出，简称UTXO。UTXO是不能再分割、被所有者锁住或记录于区块链中的并被整个网络识别成货币单位的一定量的比特币货币。比特币网络监测着以百万为单位的所有可用的（未花费的）UTXO。当一个用户接收比特币时，金额被当作UTXO记录到区块链里。这样，一个用户的比特币会被当作UTXO分散到数百个交易和数百个区块中。实际上，并不存在储存比特币地址或账户余额的地点，只有被所有者锁住的、分散的UTXO。“一个用户的比特币余额”，这个概念是一个通过比特币钱包应用创建的派生之物。比特币钱包通过扫描区块链并聚合所有属于该用户的UTXO来计算该用户的余额。



***一个UTXO可以是一“聪”的任意倍。就像美元可以被分割成表示两位小数的“分”一样，比特币可以被分割成表示八位小数的“聪”。尽管UTXO可以是任意值，但只要它被创造出来了，就像不能被切成两半的硬币一样不可再分了。如果一个UTXO比一笔交易所需量大，它仍会被当作一个整体而消耗掉，但同时会在交易中生成零头。例如，你有20比特币的UTXO并且想支付1比特币，那么你的交易必须消耗掉整个20比特币的UTXO并且产生两个输出：一个是支付了1比特币给接收人，另一个是支付19比特币的找零到你的钱包。这样的话，大部分比特币交易都会产生找零。***



就像现实生活中一样，比特币应用可以使用一些策略来满足付款需要：组合若干小的个体，算出准确的找零；或者使用一个比交易值大的个体然后进行找零。所有这些复杂的、由可支付的UTXO完成的组合，都是由用户的钱包自动完成，并不为用户所见。**只有当你以编程方式用UTXO来构建原始交易时，这些才与你有关。**

被交易消耗的UTXO被称为交易输入，由交易创建的UTXO被称为交易输出。通过这种方式，一定量的比特币价值在不同所有者之间转移，并在交易链中消耗和创建UTXO。一笔比特币交易通过使用所有者的签名来解锁UTXO，并通过使用新的所有者的比特币地址来锁定并创建UTXO。

**对于输出和输入链来说，有一个例外，它是一种特殊的交易类型，称为Coinbase交易。这是每个区块中的首个交易。这种交易存在的原因是作为对挖矿的奖励而产生全新的可用于支付的比特币给“赢家”矿工。**

#### 支付条件（障碍）

交易输出把用聪表示的一定数量的比特币，和特定的定义了支付输出所必须被满足的条件的障碍，或者叫锁定脚本，关联到了一起。在大多数情况下，锁定脚本会把输出锁在一个特定的比特币地址上，从而把一定数量的比特币的所有权转移到新的所有者上。当Alice在Bob的咖啡店为一杯咖啡付款时，Alice的交易创造了0.015比特币的输出，在咖啡店的比特币地址上成为一种障碍，或者说是被锁在了咖啡店的比特币地址上。那0.015比特币输出被记录到区块链中，并且成为UTXO的一部分，也就是作为可用余额出现在Bob的钱包里。当Bob选择使用这笔款项进行支付时，他的交易会释放障碍，通过提供一个包含Bob私钥的解锁脚本来解锁输出。

### 交易输入

简单地说，交易输入是指向UTXO的指针。它们指向特定的UTXO，并被交易哈希和在区块链中记录UTXO的序列号作为参考。若想支付UTXO，一个交易的输入也需要包含一个解锁脚本，用来满足UTXO的支付条件。解锁脚本通常是一个签名，用来证明对于在锁定脚本中的比特币地址拥有所有权。

### 交易费

大多数交易包含交易费，这是为了在网络安全方面给比特币矿工一种补偿。在第8章中，对于挖矿、费用和矿工得到的奖励，有更详细的讨论。这一节解释交易费是如何被包含在日常交易中的。大多数钱包自动计算并计入交易费。但是，**如果你编程构造交易，或者使用命令行接口，你必须手动计算并计入这些费用。**

### 把交易费加到交易中

交易的数据结构没有交易费的字段。相反地，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示。从所有输入中扣掉所有输出之后的多余的量会被矿工收集走。

交易费被作为输入减输出的余量：

```
交易费 = 求和（所有输入） - 求和（所有输出）
```

对于交易来说，这是一个很让人摸不着头脑的元素，但又是很重要的问题。因为如果你要构造你自己的交易，你必须确认你没有疏忽地包含了一笔少于输入的、量非常大的费用。这意味着你必须计算所有的输入，如果必要的话进行找零，不然的话，结果就是你给了矿工一笔可观的劳动费！

### P2PKH（Pay-to-Public-Key-Hash）

比特币网络上的大多数交易都是P2PKH交易，此类交易都含有一个锁定脚本，该脚本由公钥哈希实现阻止输出功能，公钥哈希即为广为人知的比特币地址。由P2PKH脚本锁定的输出可以通过键入公钥和由相应私钥创设的数字签名得以解锁。

### P2PK（Pay-to-Public-Key）

与P2PKH相比，P2PK模式更为简单。与P2PKH模式含有公钥哈希的模式不同，在P2PK脚本模式中，公钥本身已经存储在锁定脚本中，而且代码长度也更短。P2PKH是由Satoshi创建的，主要目的一方面为使比特币地址更简短，另一方面也使之更方便使用。P2PK目前在Coinbase交易中最为常见，Coinbase交易由老的采矿软件产生，目前还没更新至P2PKH。

## P2P网络架构

每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务

### 基础概念

比特币系统是没有余额的概念的，它使用的是UTXO模型（Unspent Transaction Outputs，未使用过的交易输出），我们在交易过程中经常说的钱包余额，实际上是一个钱包地址的UTXO集合。所以，在比特币网络中，存储比特币余额的是交易输出，准确点说就是未使用过的交易输出。

### 交易类型

* Coinbase交易（挖矿奖励）
* 普通交易（A给B转账）

交易有两种类型

一种是Coinbase交易，也就是挖矿奖励的比特币，由于没有发送人，所以比较特殊。

另一种就是我们常见的普通交易了，包含输入和输出的。

一笔交易包含输入和输出。

输出中，包含当前输出的索引、金额、锁定脚本和接受者的公钥，锁定脚本的作用是，设定成只有接受者的公钥对应的用户才能使用这笔输出。而要使用这个UTXO，就必须要证明自己是接受者公钥对应的用户。



### 进行一笔交易（转账）

第一步就是要确认自己有没有足够的“余额”去支付这笔交易。

而要计算用户的余额，就要遍历对应用户的所有交易记录。确认可以支付这笔交易之后，才可以发起一笔交易。

第二步就是创建一笔交易，这笔交易就必须包括输入和输出，输入和输出都有可能是一个或多个。

输入包括

* 未花费的交易输出的哈希值
* 未花费的交易输出的索引号
* 交易发起者公钥
* 解锁脚本（签名和公钥）

从哈希值和索引号这两个字段到历史里查，可得到可用的金额。用公钥去验证签名就保证了所属的权利。

输出包括

* 索引号
* 金额
* 锁定脚本
* 接受者的公钥

***使用公钥对用户的签名（私钥加密）进行验证从而证明签名者是否用户本人***



btcd的源码

block

```
type MsgBlock struct {
	Header       BlockHeader
	Transactions []*MsgTx
}

```

blockheader

```
// BlockHeader defines information about a block and is used in the bitcoin
// block (MsgBlock) and headers (MsgHeaders) messages.
type BlockHeader struct {
  //版本号，用于跟踪软件/协议的更新
	// Version of the block.  This is not the same as the protocol version.
	Version int32

  //引用区块链中父区块的哈希值
	// Hash of the previous block header in the block chain.
	PrevBlock chainhash.Hash

  //该区块中交易的merkle树根的哈希值
	// Merkle tree reference to hash of all transactions for the block.
	MerkleRoot chainhash.Hash

  //该区块产生的近似时间（精确到秒的Unix时间戳）
	// Time the block was created.  This is, unfortunately, encoded as a
	// uint32 on the wire and therefore is limited to 2106.
	Timestamp time.Time

	// Difficulty target for the block.
	//难度
	Bits uint32  
  //用于工作量证明算法的计数器
	// Nonce used to generate the block.
	Nonce uint32
}
```

transaction

```
type MsgTx struct {
	Version  int32 //版本,明确这笔交易参照的规则
	TxIn     []*TxIn //一个或多个交易输入
	TxOut    []*TxOut //一个或多个交易输出
	LockTime uint32 //一个UNIX时间戳或区块号
}
```

txin

```
type TxIn struct {
	PreviousOutPoint OutPoint
	SignatureScript  []byte  //解锁脚本
	Witness          TxWitness //type TxWitness [][]byte
	Sequence         uint32
}
```

OutPoint

```
type OutPoint struct {
	Hash  chainhash.Hash //引用的交易哈希
	Index uint32 //索引
}
```



txout

```
type TxOut struct {
	Value    int64    //金额
	PkScript []byte  //锁定脚本
}

```



区块链是由包含交易信息的区块从后向前有序链接起来的数据结构。它可以被存储为flat file（一种包含没有相对关系记录的文件），或是存储在一个简单数据库中。比特币核心客户端使用Google的LevelDB数据库存储区块链元数据

你可以把区块链想象成地质构造中的地质层或者是冰川岩芯样品。表层可能会随着季节而变化，甚至在沉积之前就被风吹走了。但是越往深处，地质层就变得越稳定。到了几百英尺深的地方，你看到的将是保存了数百万年但依然保持历史原状的岩层。在区块链里，最近的几个区块可能会由于区块链分叉所引发的重新计算而被修改。最新的六个区块就像几英寸深的表土层。但是，超过这六块后，区块在区块链中的位置越深，被改变的可能性就越小。在100个区块以后，区块链已经足够稳定，这时Coinbase交易（包含新挖出的比特币的交易）可以被支付。几千个区块（一个月）后的区块链将变成确定的历史，永远不会改变。



# 区块链

区块链是由包含交易信息的区块从后向前有序链接起来的数据结构。它可以被存储为flat file（一种包含没有相对关系记录的文件），或是存储在一个简单数据库中。比特币核心客户端使用Google的LevelDB数据库存储区块链元数据。区块被从后向前有序地链接在这个链条里，每个区块都指向前一个区块。区块链经常被视为一个垂直的栈，第一个区块作为栈底的首区块，随后每个区块都被放置在其他区块之上。

对每个区块头进行SHA256加密哈希，可生成一个哈希值。通过这个哈希值，可以识别出区块链中的对应区块。同时，每一个区块都可以通过其区块头的“父区块哈希值”字段引用前一区块（父区块）。也就是说，每个区块头都包含它的父区块哈希值。这样把每个区块链接到各自父区块的哈希值序列就创建了一条一直可以追溯到第一个区块（创世区块）的链条。

虽然每个区块只有一个父区块，但可以暂时拥有多个子区块。每个子区块都将同一区块作为其父区块，并且在“父区块哈希值”字段中具有相同的（父区块）哈希值。一个区块出现多个子区块的情况被称为“区块链分叉”。区块链分叉只是暂时状态，只有当多个不同区块几乎同时被不同的矿工发现时才会发生（参见“8.10.1 区块链分叉”）。最终，只有一个子区块会成为区块链的一部分，同时解决了“区块链分叉”的问题。尽管一个区块可能会有不止一个子区块，但每一区块只有一个父区块，这是因为一个区块只有一个“父区块哈希值”字段可以指向它的唯一父区块。

由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值因此也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。父区块的哈希值发生改变将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，等等以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是因为这样的重新计算需要耗费巨大的计算量，所以一个长区块链的存在可以让区块链的历史不可改变，这也是比特币安全性的一个关键特征。

你可以把区块链想象成地质构造中的地质层或者是冰川岩芯样品。表层可能会随着季节而变化，甚至在沉积之前就被风吹走了。但是越往深处，地质层就变得越稳定。到了几百英尺深的地方，你看到的将是保存了数百万年但依然保持历史原状的岩层。在区块链里，最近的几个区块可能会由于区块链分叉所引发的重新计算而被修改。最新的六个区块就像几英寸深的表土层。但是，超过这六块后，区块在区块链中的位置越深，被改变的可能性就越小。在100个区块以后，区块链已经足够稳定，这时Coinbase交易（包含新挖出的比特币的交易）可以被支付。几千个区块（一个月）后的区块链将变成确定的历史，永远不会改变。



### 区块哈希值

区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：***区块头哈希值，因为只有区块头被用于计算。**区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。请注意，**区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为区块链的一部分被存储在某节点的永久性存储设备上时。**相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。

**区块高度也不是区块数据结构的一部分，它并不被存储在区块里。当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。**

区块头结构

| 大小   | 字段         | 描述                                         |
| ------ | ------------ | -------------------------------------------- |
| 4字节  | 版本         | 版本号，用于跟踪软件/协议的更新              |
| 32字节 | 父区块哈希值 | 引用区块链中父区块的哈希值                   |
| 32字节 | Merkle根     | 该区块中交易的merkle树根的哈希值             |
| 4字节  | 时间戳       | 该区块产生的近似时间（精确到秒的Unix时间戳） |
| 4字节  | 难度目标     | 该区块工作量证明算法的难度目标               |
| 4字节  | Nonce        | 用于工作量证明算法的计数器                   |

矿工们在挖矿过程中会得到两种类型的奖励：创建新区块的新币奖励，以及区块中所含交易的交易费

每笔交易都可能包含一笔交易费，交易费是每笔交易记录的输入和输出的差额。

比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：

▷ 每个全节点依据综合标准对每个交易进行独立验证

▷ 通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块，

▷ 每个节点独立的对新区块进行校验并组装进区块链

▷ 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链



每一个节点在校验每一笔交易时，都需要对照一个长长的标准列表：

▷交易的语法和数据结构必须正确。

▷输入与输出列表都不能为空。

▷交易的字节大小是小于`MAX_BLOCK_SIZE`的。

▷每一个输出值，以及总量，必须在规定值的范围内 （小于2,100万个币，大于0）。

▷没有哈希等于0，N等于-1的输入（coinbase交易不应当被中继）。

▷nLockTime是小于或等于`INT_MAX`的。

▷交易的字节大小是大于或等于100的。

▷交易中的签名数量应小于签名操作数量上限。

▷解锁脚本（`scriptSig`）只能够将数字压入栈中，并且锁定脚本（`scriptPubkey`）必须要符合isStandard的格式 （该格式将会拒绝非标准交易）。

▷池中或位于主分支区块中的一个匹配交易必须是存在的。

▷对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝。

▷对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入到孤立交易池中。

▷对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入必须至少获得`COINBASE_MATURITY` (100)个确认。

▷对于每一个输入，引用的输出是必须存在的，并且没有被花费。

▷使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内 （小于2100万个币，大于0）。

▷如果输入值的总和小于输出值的总和，交易将被中止。

▷如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝。

▷每一个输入的解锁脚本必须依据相应输出的锁定脚本来验证。

这些条件能够在比特币标准客户端下的`AcceptToMemoryPool`、`CheckTransaction`和`CheckInputs`函数中获得更详细的阐述。请注意，这些条件会随着时间发生变化，为了处理新型拒绝服务攻击，有时候也为交易类型多样化而放宽规则。

在收到交易后，，每一个节点都会在全网广播前对这些交易进行校验，并以接收时的相应顺序，为有效的新交易建立一个池（交易池）。

